Because we use git for version control, we must always remain conscious of what we are doing when we make a new commit. Every action we take with our repositories alters the commit history. We are not only maintaining and developing software; we are also maintaining and developing the commit history tracked by git. Much as it is important for us to be mindful that our code is readable, it is also important to be mindful that we leave a readable, sensible, linear commit history. A good commit history tells us what modifications were made and in what order. By using git rebase, we can create a linear commit history that is also completely readable.
To understand what is valuable about git rebase, consider the following scenario. Let's say you go into work and, every morning, you merge master into your separate branch (call it feature), work on your local repository for a while, and then merge your branch, feature, back into master. We can assume that, if you did this for one day, the result may look something like this (fig. 1):
Now, let's say you and two coworkers, Alice and Bob, do so, and that your coworkers use albranch and bobranch for their branches. Your branch will be called yobranch. The result might look like this (fig. 2):
This reflects what the commit history looks like after a single day of work by a team of only three people. Imagine how it would look after four teams of four worked on it for six months! The most complex arrangements of river deltas, arteries, or tree roots would not remotely compare. Obviously, such a commit history is horribly inefficient, not to mention hideous.
We solve this problem through consistent and judicious use of the git rebase command. Whereas git merge (typically) creates a merge commit, git rebase allows us to create a linear and readable commit history through the use of a few simple commands.
Before I go any further, I want to introduce something that is often called the golden rule of git. The golden rule of git is as follows: never rebase a public resource. So if your feature branch has already been pushed to the remote repository, you can't assume that nobody has pulled it yet. Therefore, you can't rebase it, because rebasing that public branch alters a resource that may be upstream of other people's repositories, which would interfere with their work.
So after doing our work on the feature branch of our project, we create a new branch that is private for us. Let's call it feature2. The usual way to do this would be to type git checkout -b feature2 into the terminal. This creates a new branch, feature2, that includes everything that feature includes. We then rebase feature2 onto master. We do this because rebasing feature would alter feature, and if someone else had feature as an upstream branch, this would then flow downstream into their work; famously, bad things flow downhill. 
The problem, of course, is that if we do work on feature, we want to rebase that work onto the master branch, but cannot do so for the reasons just mentioned. Creating feature2 as a branch on top of feature gets around this beautifully by creating a private branch qualitatively identical* to the public one we would like to commit. We rebase this copycat branch onto master, squash all of its commits into one, and then merge it into master. This can be done with the following sequence of commands:
git checkout -b feature2
This yields the situation in fig. 3.
git rebase -i master
This allows you to squash the other commits and drop a single rebased commit oto the feature2 branch off of master, without harming the feature branch. It looks like fig 4.
git checkout master
git merge feature2
This mergest feature2 into master, making sure that, when we commit and push our changes, they show up as one neat little commit on the perfectly linear master branch. It results in what you see in fig 5.
*Definitions of qualitative and quantitative identity ought to be given in the glossary.