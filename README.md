# git-book
The Illustrated Guide to Git, or some such title.

TO DO

The idea of this book is basically a progressive difficulty as you go forward. Begin with a nice cartoony kindergarteny explanation in chapter 1 that covers all the basic git commands. This chapter is suitable for the incompetent do-nothing turkeys in management. Even they will get it.

Chapter two will strip away all the pedagogic devices and just leave the bare syntactic structure, which will be very skeletal since chapter one is the most gentle introduction possible. Chapter two will explain a little more about branching, commits, merging, cherry-pick, and some of the more complicated commands. It will also get a little more fundamental in explaining what git does and does not track, in order to make the commands make sense. It won't be TOO fundamental, though, because that level of understanding isn't available to your 120 code monkey.

Chapter three will be much more fundamental -- I can't foresee past this point because I need to learn more git. I'm gonna keep it up though.

**********************************************

Let's say that you're a programmer, and you want to begin working on a project. The project belongs to a team that uses git. So, how do you get started on the project, knowing that the team uses git for development? And what is git for, anyway?

You begin by finding their REMOTE REPOSITORY, which is basically just a set of files. A lot of remote repositories are listed on sites like Github; some are listed on other websites; some are hosted on private servers not accessible to the public. The remote repository contains all of the files for the project.

Since we're using git, we begin our work by CLONING the remote repository. You can do this in your terminal window by typing "git clone" followed by an URL(or SSH key)  that goes to the directory you want to clone. When you type that into your system, you create a copy of the remote repository on your computer. You now have a copy on your computer, and that copy is called the LOCAL REPOSITORY. The local repository contains all the files that the remote repository does.

Okay, so you have all the files you need now. But why not just send the files via email, or a thumb drive, or have you download them from a website? Why use this git thing specifically? The answer is that git is there to keep track of what changes we make, and make it easy for everyone to stay on the same page with new changes and, if necessary, revert to the old ones. Git makes it so that lots of people can work on the project all at the same time without anybody getting confused or making contradictory changes that cause problems, like making the program collapse.

Once you download all those files from the local repository using "git clone", you can begin working. You can make any changes you want. When you make a change, you create something called a COMMIT. A git commit is like a snapshot of the project at one point in time. The remote repository shows you a snapshot of the project as it is now. Once you clone the repository with "git clone", and make changes, you can type "git status" into your terminal. Git status will show you, among other things, what files have been changed. You will type "git add" followed by the name of a file that has been changed in order to STAGE that file. Staging a file means getting it ready to be made into a commit. Once you type "git add" and stage all of the files you want to change, you can type "git commit -m" followed by a message stating what changes you're making. "Git add" is like putting a file on a stage so you can take a picture of it, and "git commit" is what actually takes the snapshot. Once you've committed your changes, you've created a snapshot, which is what a commit is. Once you've made your commit, you can, if you so choose, type "git push" and PUSH that change to the remote repository. If there are any staged files that you would like to "take off stage," so to speak, then you can do so by typing "git restore --staged <filename>" and they will be removed.

You might still be wondering what the purpose of git is. Couldn't you do all this stuff without some fancy tool like git? But the power of git is its ability to keep records, to keep track of things, without taking up a lot of resources. What if you made a change that turned out not to be any good? What if the team decided that some of their changes should be undone? What if you all agreed to revert to an earlier version? Again, git is powerful because it keeps track of changes and records them, and it does so in a way that does not consume many  resources. Since git keeps track of all these things, it makes it easy to revert to older versions, or to backtrack and see what went wrong.

One of the ways that git helps us do this is by using something called a BRANCH. When you make a new commit, you usually (though not always) are doing so with a branch. You can think of commits like little circles, and of branches like lines connecting those circles. The way that commits are connected to one another is through branches. A commit can contain something called a POINTER, which is a little code that says whih commit that commit was changed from. If I take a commit 1, and make changes to it to create commit 2, then commit 2 can contain a pointer that points to commit 1. The pointer in commit 2 basically says "Hey! This commit that contains me was made from commit 1, which is the PARENT of this commit." Entering "git branch" into your terminal will show you every branch in your local repository, every branch in your local copy of the system. Meanwhile, entering "git branch -a" will show you every branch in your local repository and in every remote repository that you are connected to.

If you've ever read about your family's history, you may have seen a genealogy. A genealogy of your father, his father, and his father, could be represented similarly to a series of git commits. You would be represented by a circle at the bottom of the page, with a line pointing up to another circle. That second circle would represent your father. That second circle, your father, would have a line pointing to his father, your grandfather, who is a third circle. You could continue drawing lines like this to represent all of your ancestors. Git branches work in a similar way: git commits can have branches that point to their parents. You have to remember, though, that this is just an analogy. In reality, branches are not simple lines, independent of the commits they connect. Rather, a branch is a pointer in a commit, that points to its parent; its parent, in turn will have a pointer that points to its previous parent; that parent will have a pointer that points to a previous parent; and so on.

(Earlier, I mentioned the "git status" command and said it could tell you a lot of things. Well, one of the other things it can tell you is what branch you're working on right now.)

Speaking of where we are right now, there is another important git command that everyone who uses git should know: "git checkout". Git checkout moves us to a different branch or commit. If you visualize the commit history like the genealogy above, with circles connected by lines, git checkout allows us to move between different circles. There is a thing called the HEAD, which points at whatever commit or branch we're currently working with. If you're currently working on a branch called bugFix, then HEAD points to bugFix. If HEAD points at the last commit you made, then you're currently working on the last commit you made. HEAD points to whatever you're currently working on, and you're currently working on whatever HEAD points to. The current object you're working on, and the thing that HEAD is pointing at, are one and the same thing, by definition. Typing "git checkout" followed by a branch or commit makes HEAD point to that branch or commit. Remember what I said, about how "git status" tells you what branch you're working on? Well, it also tells you what HEAD is currently pointing at.

When you make a new commit, what happens afterward depends on what HEAD is pointing to. In the case I described earlier, we implicitly assumed (though I didn't say it outright) that HEAD was pointing to a branch. So if commit 2 has a branch called bugFix, and HEAD is pointing to bugFix, then typing "git commit" and making a new commit will create commit 3. The bugFix branch will now be on commit 3, and it will point back to commit 2; on commit 2, the bugFix bra
nch will point to commit 1.

However, HEAD does not always point to a branch. Sometimes, HEAD will instead point to a commit itself, instead of the branch that the commit lies on. If you create a new commit using "git commit" while HEAD points to a commit instead of a branch, then the new commit will not be connected to any branch at all. Newly-made commits are only connected to branches if they are created while HEAD is pointing to a branch. If HEAD is pointing to a commit instead, then you get an isolated commit, a circle unconnected to any lines. If you want your new commit will have a branch that points to its parent, then you should make sure that HEAD is pointing to the branch of your current commit. To do that, you can type "git status" to check where HEAD is pointing right now. If HEAD is not pointing to the current branch, then just type "git checkout" followed by the name of the branch, and HEAD will now point to that branch, which means that you are now working on that branch. Now, since HEAD is pointing to the branch, you can type "git commit -m" followed by a note of the changes you're making, and then press enter, and your new git commit will be on the same branch as the present one.

You may be wondering how git keeps track of commits. It does so using hashes, or special codes that designate each and every commit. These codes are many characters long and look like gibberish, although the computer recognizes them. To make commits easier for us to keep track of, we can use "git checkout <hash>" to checkout a commit (not a branch) and then use "git tag <made up name>" to make up a special name for the commit that we can use to keep track of it. The commit will still have its hash, its special code, so that the computer can keep track of it, but it will also have its new tag that you created. You can think of the tag as a nickname for the commit.

There are two final commands that we need to understand in order to achieve basic git competence. They are the "git merge" and "git rebase" commands. By now, with the analogy to genealogy, you should understand that git rapidly branches into many many different commits. With all of that branching and splitting, there would be no way to maintain a coherent project without merging those split-up branches together. Both "git merge" and "git rebase" allow us to do that, albeit in very, very different ways.

"Git merge" is the more simple command, so I'll describe that one first. Suppose you have a bugFix branch, and a master branch. Furthermore suppose that you are currently checked out on the bugFix branch. If you type "git merge master," then that closes the fork in the git history. If you could write out the commits using the line-and-circle format that I described before, you would see the two branches come together in a new commit that combines all of the changes from both branches. This is "git merge" and it is the simplest way of combining two forked git branches.

"Git rebase" is somewhat more sophisticated and can be a little risky for new users, because it can cause a headache for the team if misused. However, if you pay close a attention to this description of how to use it, you'll be just fine. "Git rebase" is takes the current branch or commit, and traces all of the changes made since it diverged from the branch it is being merged into, and then replays those changes on top of the other branch. Suppose we have a commit history that looks like this:

          A---B---C topic
         /
    D---E---F---G  master

If HEAD currently points to commit C, or to the branch that C is on, then typing "git rebase master" will take A, B, and C -- all the commits since the branch diverged from master at E -- and replay them on top of G:


                   A'---B'---C' topic
                  /
    D---E---F---G master

If this seems complicated, then you can think of it as chopping off the branch beginning with A, and then grafting it onto the end of G. This effectively rewrites the commit history. While cutting out part of the history may seem to create a disadvantage, since you lose the ability to see how everything came together, it can also be very good for keeping the commit history organized. Since the "git merge" command creates a new commit to show the merge, it can easily clutter up the commit history. By contrast, "git rebase" can keep the commit history clean and even perfectly linear. It can be risky, though, since it effectively rewrites the commit history and can lead to some very confusing situations. The best rule of thumb is to never rebase a public branch on top of one of your private ones: this avoids the biggest problems.