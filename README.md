# git-book
The Illustrated Guide to Git, or some such title.

TO DO

The idea of this book is basically a progressive difficulty as you go forward. Begin with a nice cartoony kindergarteny explanation in chapter 1 that covers all the basic git commands. This chapter is suitable for the incompetent do-nothing turkeys in management. Even they will get it.

Chapter two will strip away all the pedagogic devices and just leave the bare syntactic structure, which will be very skeletal since chapter one is the most gentle introduction possible. Chapter two will explain a little more about branching, commits, merging, cherry-pick, and some of the more complicated commands. It will also get a little more fundamental in explaining what git does and does not track, in order to make the commands make sense. It won't be TOO fundamental, though, because that level of understanding isn't available to your 120 code monkey.

Chapter three will be much more fundamental -- I can't foresee past this point because I need to learn more git. I'm gonna keep it up though.

**********************************************

Let's say that you're a programmer, and you want to begin working on a project. The project belongs to a team that uses git. So, how do you get started on the project, knowing that the team uses git for development? And what is git for, anyway?

You begin by finding their REMOTE REPOSITORY, which is basically just a set of files. A lot of remote repositories are listed on sites like Github; some are listed on other websites; some are hosted on private servers not accessible to the public. The remote repository contains all of the files for the project.

Since we're using git, we begin our work by CLONING the remote repository. You can do this in your terminal window by typing "git clone" followed by an URL(or SSH key)  that goes to the directory you want to clone. When you type that into your system, you create a copy of the remote repository on your computer. You now have a copy on your computer, and that copy is called the LOCAL REPOSITORY. The local repository contains all the files that the remote repository does.

Okay, so you have all the files you need now. But why not just send the files via email, or a thumb drive, or have you download them from a website? Why use this git thing specifically? The answer is that git is there to keep track of what changes we make, and make it easy for everyone to stay on the same page with new changes and, if necessary, revert to the old ones. Git makes it so that lots of people can work on the project all at the same time without anybody getting confused or making contradictory changes that cause problems, like making the program collapse.

Once you download all those files from the local repository using "git clone", you can begin working. You can make any changes you want. When you make a change, you create something called a COMMIT. A git commit is like a snapshot of the project at one point in time. The remote repository shows you a snapshot of the project as it is now. Once you clone the repository with "git clone", and make changes, you can type "git status" into your terminal. Git status will show you, among other things, what files have been changed. You will type "git add" followed by the name of a file that has been changed in order to STAGE that file. Staging a file means getting it ready to be made into a commit. Once you type "git add" and stage all of the files you want to change, you can type "git commit -m" followed by a message stating what changes you're making. "Git add" is like putting a file on a stage so you can take a picture of it, and "git commit" is what actually takes the snapshot. Once you've committed your changes, you've created a snapshot, which is what a commit is. Once you've made your commit, you can, if you so choose, type "git push" and PUSH that change to the remote repository. If there are any staged files that you would like to "take off stage," so to speak, then you can do so by typing "git restore --staged <filename>" and they will be removed.

You might still be wondering what the purpose of git is. Couldn't you do all this stuff without some fancy tool like git? But the power of git is its ability to keep records, to keep track of things, without taking up a lot of resources. What if you made a change that turned out not to be any good? What if the team decided that some of their changes should be undone? What if you all agreed to revert to an earlier version? Again, git is powerful because it keeps track of changes and records them, and it does so in a way that does not consume many  resources. Since git keeps track of all these things, it makes it easy to revert to older versions, or to backtrack and see what went wrong.

One of the ways that git helps us do this is by using something called a BRANCH. When you make a new commit, you usually (though not always) are doing so with a branch. You can think of commits like little circles, and of branches like lines connecting those circles. The way that commits are connected to one another is through branches. A commit can contain something called a POINTER, which is a little code that says whih commit that commit was changed from. If I take a commit 1, and make changes to it to create commit 2, then commit 2 can contain a pointer that points to commit 1. The pointer in commit 2 basically says "Hey! This commit that contains me was made from commit 1, which is the PARENT of this commit." Entering "git branch" into your terminal will show you every branch in your local repository, every branch in your local copy of the system. Meanwhile, entering "git branch -a" will show you every branch in your local repository and in every remote repository that you are connected to.

If you've ever read about your family's history, you may have seen a genealogy. A genealogy of your father, his father, and his father, could be represented similarly to a series of git commits. You would be represented by a circle at the bottom of the page, with a line pointing up to another circle. That second circle would represent your father. That second circle, your father, would have a line pointing to his father, your grandfather, who is a third circle. You could continue drawing lines like this to represent all of your ancestors. Git branches work in a similar way: git commits can have branches that point to their parents. You have to remember, though, that this is just an analogy. In reality, branches are not simple lines, independent of the commits they connect. Rather, a branch is a pointer in a commit, that points to its parent; its parent, in turn will have a pointer that points to its previous parent; that parent will have a pointer that points to a previous parent; and so on.

(Earlier, I mentioned the "git status" command and said it could tell you a lot of things. Well, one of the other things it can tell you is what branch you're working on right now.)

Speaking of where we are right now, there is another important git command that everyone who uses git should know: "git checkout". Git checkout moves us to a different branch or commit. If you visualize the commit history like the genealogy above, with circles connected by lines, git checkout allows us to move between different circles. There is a thing called the HEAD, which points at whatever commit or branch we're currently working with. If you're currently working on a branch called bugFix, then HEAD points to bugFix. If HEAD points at the last commit you made, then you're currently working on the last commit you made. HEAD points to whatever you're currently working on, and you're currently working on whatever HEAD points to. The current object you're working on, and the thing that HEAD is pointing at, are one and the same thing, by definition. Typing "git checkout" followed by a branch or commit makes HEAD point to that branch or commit. Remember what I said, about how "git status" tells you what branch you're working on? Well, it also tells you what HEAD is currently pointing at.

When you make a new commit, what happens afterward depends on what HEAD is pointing to. In the case I described earlier, we implicitly assumed (though I didn't say it outright) that HEAD was pointing to a branch. So if commit 2 has a branch called bugFix, and HEAD is pointing to bugFix, then typing "git commit" and making a new commit will create commit 3. The bugFix branch will now be on commit 3, and it will point back to commit 2; on commit 2, the bugFix bra
nch will point to commit 1.

However, HEAD does not always point to a branch. Sometimes, HEAD will instead point to a commit itself, instead of the branch that the commit lies on. If you create a new commit using "git commit" while HEAD points to a commit instead of a branch, then the new commit will not be connected to any branch at all. Newly-made commits are only connected to branches if they are created while HEAD is pointing to a branch. If HEAD is pointing to a commit instead, then you get an isolated commit, a circle unconnected to any lines. If you want your new commit will have a branch that points to its parent, then you should make sure that HEAD is pointing to the branch of your current commit. To do that, you can type "git status" to check where HEAD is pointing right now. If HEAD is not pointing to the current branch, then just type "git checkout" followed by the name of the branch, and HEAD will now point to that branch, which means that you are now working on that branch. Now, since HEAD is pointing to the branch, you can type "git commit -m" followed by a note of the changes you're making, and then press enter, and your new git commit will be on the same branch as the present one.

You may be wondering how git keeps track of commits. It does so using hashes, or special codes that designate each and every commit. These codes are many characters long and look like gibberish, although the computer recognizes them. To make commits easier for us to keep track of, we can use "git checkout <hash>" to checkout a commit (not a branch) and then use "git tag <made up name>" to make up a special name for the commit that we can use to keep track of it. The commit will still have its hash, its special code, so that the computer can keep track of it, but it will also have its new tag that you created. You can think of the tag as a nickname for the commit.

There are two final commands that we need to understand in order to achieve basic git competence. They are the "git merge" and "git rebase" commands. By now, with the analogy to genealogy, you should understand that git rapidly branches into many many different commits. With all of that branching and splitting, there would be no way to maintain a coherent project without merging those split-up branches together. Both "git merge" and "git rebase" allow us to do that, albeit in very, very different ways.

"Git merge" is the more simple command, so I'll describe that one first. Suppose you have a bugFix branch, and a master branch. Furthermore suppose that you are currently checked out on the bugFix branch. If you type "git merge master," then that closes the fork in the git history. If you could write out the commits using the line-and-circle format that I described before, you would see the two branches come together in a new commit that combines all of the changes from both branches. This is "git merge" and it is the simplest way of combining two forked git branches.

"Git rebase" is somewhat more sophisticated and can be a little risky for new users, because it can cause a headache for the team if misused. However, if you pay close a attention to this description of how to use it, you'll be just fine. "Git rebase" is takes the current branch or commit, and traces all of the changes made since it diverged from the branch it is being merged into, and then replays those changes on top of the other branch. Suppose we have a commit history that looks like this:

          A---B---C topic
         /
    D---E---F---G  master

If HEAD currently points to commit C, or to the branch that C is on, then typing "git rebase master" will take A, B, and C -- all the commits since the branch diverged from master at E -- and replay them on top of G:


                   A'---B'---C' topic
                  /
    D---E---F---G master

If this seems complicated, then you can think of it as chopping off the branch beginning with A, and then grafting it onto the end of G. This effectively rewrites the commit history. While cutting out part of the history may seem to create a disadvantage, since you lose the ability to see how everything came together, it can also be very good for keeping the commit history organized. Since the "git merge" command creates a new commit to show the merge, it can easily clutter up the commit history. By contrast, "git rebase" can keep the commit history clean and even perfectly linear. It can be risky, though, since it effectively rewrites the commit history and can lead to some very confusing situations. The best rule of thumb is to never rebase a public branch on top of one of your private ones: this avoids the biggest problems.


*************************************************************************

If you're reading this book, you are presumably an IT professional who finds it to their benefit to learn git. This text is addressed to a hypothetical user who has joined a development team that uses git. The hypothetical user is presumed to have no prior knowledge of the subject.
(save this for intro later)
****************************************************************************

OUTLINE FOR 2ND DRAFT
1. Explain the clone command, then checkout and branch. The purpose of this is to learn to move around.
   1.5 Explain that commit refers to an object in git but also to a command, both a "noun" and a "verb." 
2. Explain status, add, commit. Segue into this by explaining that status will display the current branch, and also things that have not yet been added or committed. Explain restore.
3. Explain merge and rebase. Rebase is explained because it is similar to merge and merge is explained because it is a precursor to understanding pull.
4. Explain pull, push, and fetch.


So you're getting started with a new project with a team who use git. You'll need to make a copy of their repository on your machine. This copy is known as a LOCAL REPOSITORY and can be created using the CLONE command. The clone command is initiated by typing "git clone xxxxx" into your terminal, where xxxxx is the http or ssh address of the repository you want to clone. The process of getting the http or ssh address can vary depending on who you're working with and how they do their projects. For example, at the time of this writing, you can get the http address of a project hosted on github by clickig the green "clone or download" button on the project page. Your organization may have a different process for obtaining the address.

So let's say you have the address for the git repository, and you type "git clone" followed by that address. HINTBOX[Most terminal programs allow you to paste using ctrl+insert] This creates a copy of the repository on your machine. The repository you just copied is known as the remote repository, the one far away. The repository on your machine is the local repository, the one you have hanging around. There is a lot of stuff going on "under the hood" when you create your local repository. In addition to copying everything from the remote repository, there are some other git-specific files created that serve as an apparatus to allow the git tools to work. We'll look at those in detail later, but if you want to get a look at them now, just cd into your local repository and type "ls -a" to see them.

Git projects have multiple branches. You can think of the git project as being similar to a tree, in that it forks continuously into many different branches, different versions that different developers are working on all at once. Now is a good time for us to define a COMMIT, since a commit is the basic unit, the atom, as it were, of a git project. A commit is a snapshot of all the files in the project, like a picture of a building halfway through being built. The snapshot consists of all the files, plus all the changes that have been made. When you make changes to a commit and create a new commit, you are creating a new snapshot that reflects the changes you made. Now, you may be wondering what a "snapshot" is, exactly. To explain what that is, it helps to go back to first principles: a snapshot is a way for git to store as much information as possible in as little space as possible. Git, at its core, is basically a file system, a means of storing and tracking files. To really understand git, on its own terms, we have to understand how it performs its essential function, which is storing, handling, and tracking changes in data.  To understand how git stores as much as possible in as little space as possible, take a look at this diagram (Fig. 1):

Commit C1 is made up of files A, B, C, D, and E. You change files A and D, and create a new commit, C2. The new commit is a new "snapshot." The new versions of A and D, called A' and D' (pronounced "A-Prime" and "D-Prime") are stored in C2. However, git never stores anything twice: all the files that were unchanged, B, C, and E, are only stored in the original commit, C1. In C2, B, C, and E are all replaced with pointers that point back to the original files (a "pointer" is a little code that points somewhere in memory). So instead of wasting space by storing B, C, and E again redundantly, git will instead store a pointer, something like a little sign-post pointing back to the original files. This way, git avoids ever storing anything twice.

You might still be wondering what the purpose of git is. Couldn't you do all this stuff without some fancy tool like git? But the power of git is its ability to keep records, to keep track of things, without taking up a lot of resources. What if you made a change that turned out not to be any good? What if the team decided that some of their changes should be undone? What if you all agreed to revert to an earlier version? Again, git is powerful because it keeps track of changes and records them, and it does so in a way that does not consume many  resources. Since git keeps track of all these things, it makes it easy to revert to older versions, or to backtrack and see what went wrong.

One of the ways that git helps us do this is by using something called a branch. When you make a new commit, you usually (though not always) are doing so with a branch. You can think of commits like little circles, and of branches like lines connecting those circles. The way that commits are connected to one another is through branches. If I take a commit 1, and make changes to it to create commit 2, then commit 2 can contain a pointer that points to commit 1. The pointer in commit 2 basically says "Hey! This commit that contains me was made from commit 1, which is the PARENT of this commit." Entering "git branch" into your terminal will show you every branch in your local repository, every branch in your local copy of the system. Meanwhile, entering "git branch -a" will show you every branch in your local repository and in every remote repository that you are connected to.

If you've ever read about your family's history, you may have seen a genealogy. A genealogy of your father, his father, and his father, could be represented similarly to a series of git commits. You would be represented by a circle at the bottom of the page, with a line pointing up to another circle. That second circle would represent your father. That second circle, your father, would have a line pointing to his father, your grandfather, who is a third circle. You could continue drawing lines like this to represent all of your ancestors. Git branches work in a similar way: git commits can have branches that point to their parents. You have to remember, though, that this is just an analogy. In reality, branches are not simple lines, independent of the commits they connect. Rather, a branch is a pointer in a commit, that points to its parent; its parent, in turn will have a pointer that points to its previous parent; that parent will have a pointer that points to a previous parent; and so on until the first parent. The last "descendent" in the line, the most recent commit, is called the "head" of that branch.

So now we know what branches are! Now it's time to learn to move from branch to branch. We do this with the command "git checkout <branch>" which automatically takes us to the head of the branch we request. 