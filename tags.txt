The checkout command is the specification tool for git. What I mean here is that git checkout is the means by which we select the thing we want to work on. However, git checkout is multipurpose. The most immediate use, and the first one that we usually learn, is to checkout branches. However, when you checkout a branch, what happens under the hood is a bit more sophisticated than you might guess.
Recall that, since a branch runs through a series of commits back to the first commit (or wherever it initially branched from), the branch designates a number of commits, not just one. However, the checkout command points our head pointer at only one commit, which is the head commit of the branch specified. In other words, if we checkout on a branch (call it foo), then we go to the "head" of foo, which is its most recent commit. See fig 6:
The branch, "foo," includes multiple prior commits, but checking out foo will only check out commit C4.
It is possible, however, not only to check out the heads of branches, but to check out individual commits or even files.
Recall that every commit is identified in git by a hash. If you type "git commit <hash>" you will checkout that commit. If you type "git commit <hash> <filename>," then this adds the file identified by <filename> to your current repository and stages it to be committed. Git hashes are quite long and it is not efficient to type them directly. Fortunately, most terminal programs will be kind enough to copy the hash if it is double-clicked and paste it with alt-ins.
Speaking of unreadable hashes, there is an easier way to access commits. Git includes tagging functionality. Typing git tag "<name>" while checked out on a commit, or a branch pointing to a commit, will tag that commit with <name>. Tags are static and don't move from commit to commit, nor do they designate multiple commits the way branches do. Since tags stay on commits, they provide a handy way to grab a commit that you want to use. Tags are often used for versioning (i.e. 1.0, 2.0) and make it easy to find significant points in the app's development. Typing git checkout <tag> will checkout that commit in detached head state. See fig 7 for an example of a commit checked out in headless mode by accessing the tag with git checkout <tag>. Typing git tag by itself will list all the tags in your local repo.
The tags I just described are lightweight tags without annotations, just pointers with a decipherable user-generated name, basically for convenience/usability and other UI reasons, and the git tag <name> command will generate a lightweight tag if  no flags are included. If the -a flag is included, the command will create an annotated tag. Annotated tags include the name and email of the person who created the tag and can be signed with GPG privacy tools to create verified tag.
Regardless of whether they are annotated or not, tags are presumed to be private. The git push command doesn't push them to the remote repo unless you explicitly dictate that by typing git push origin <tagname> to push a particular tag. Including the flag, -tags, will push all of your created tags.